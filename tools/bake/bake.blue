global _start

: syscall ( num:eax -- result:eax ) syscall ;

: exit ( status:edi -- noret ) 60 syscall ;

: die ( err:eax -- noret ) neg exit ;
: unwrap ( result:eax -- value:eax ) dup 0 cmp ' die xl ;
: ordie ( result -- ) unwrap drop ;
: ignore ( result:eax err:edi -- ) swap dup rot cmp ' ordie xne drop ;

: fork ( -- result:eax ) 57 syscall unwrap ;
: execve ( filename:rdi argv:rsi env:rdx -- noret ) 59 syscall ordie ;

1 resd wait-status

: wait4 ( pid:edi status:rsi options:rdx usage:r10 -- result:eax ) 61 syscall ;  

\ TODO want to return wait-status @ but outputs don't flow yet
\ TODO actually need ports of WIFEXITED and WEXITSTATUS
: waitpid ( pid:edi -- ) wait-status 0 0 wait4 ordie ;

: write ( buf:esi len:edx fd:edi -- result:eax ) 1 syscall ;
: mkdir ( path:edi mode:esi -- result:eax ) 83 syscall ;

1 const stdout
-17 const exists

: bye ( -- noret ) 0 exit ;
: type ( buf len -- ) stdout write ordie ;
: newline ( -- ) s" \n" type ;

: find0 ( start:rsi -- end:rsi ) lodsb 0 cmp latest xne ; 
: cstrlen ( str:rdi -- len:rsi ) dup find0 swap sub dec ;

\ TODO this is an example of needing indirect clobber detection
: cstr>str ( cstr:rdx -- str:rsi len:rdx | rdi ) dup cstrlen xchg ;

: type-cstr ( buf -- ) cstr>str type ;
: type-cstr@ ( addr -- ) @ type-cstr ;

: mkdir ( path -- ) 0750 mkdir exists ignore ;

: build-dir ( -- ) c" .build/" ; inline
: bin-dir ( -- ) c" .build/bin/" ; inline \ TODO compile time concat
: obj-dir ( -- ) c" .build/obj/" ; inline

: make-build-dirs ( -- )
	build-dir mkdir
	bin-dir mkdir
	obj-dir mkdir 
;

1 resq cmd-name
1 resq blue-file
1 resq envp

\ TODO these are needed because we can't currently `@ var !` and retain operation size
: cmd-name! ( rcx -- ) cmd-name ! ;
: blue-file! ( rcx -- ) blue-file ! ;
: envp! ( rcx -- ) envp ! ;

: usage ( -- noret ) s" 
	usage: bake cmd somefile.blue
" 
	type bye 
;

: check-argc ( rax -- ) @ 3 cmp ' usage xne ;
: first-arg ( rax -- rax ) 16 add ; 
: second-arg ( rax -- rax ) 24 add ; 
: parse-args ( rax -- ) dup dup dup 
	check-argc
	first-arg @ cmd-name!
	c" bake.blue" blue-file! \ TODO second-arg is not right
	second-arg envp! \ TODO better name, its not an argv
;

512 const max-file-name-len

max-file-name-len resb base-file
max-file-name-len resb assembly-file
max-file-name-len resb object-file
max-file-name-len resb binary-file

\ TODO swap drop -> nip
: copy-str ( src:rsi len:rcx dest:rdi -- tail:rdi ) rot swap movsb swap drop swap rep ;
: copy-cstr ( src:rsi dest:rdi -- tail:rdi ) swap cstr>str rot copy-str ;

\ TODO swap rot -> -rot
: append-str ( tail:rdi src:rsi len:rcx -- tail:rdi ) swap rot movsb swap drop rep ; 
: append-cstr ( tail:rdi src:rsi -- tail:rdi ) cstr>str append-str ; 

\ TODO should drop .blue explicitly vs taking 5 off the length...
: build-base-file-name ( -- ) 
	blue-file @ cstr>str 5 sub base-file copy-str
;

: build-assembly-file-name ( -- ) 
	base-file assembly-file copy-cstr 
	s" .asm" append-str
;
 
: build-object-file-name ( -- ) 
	obj-dir object-file copy-cstr 
	base-file append-cstr
	s" .o" append-str
;

: build-binary-file-name ( -- ) 
	bin-dir binary-file copy-cstr
	base-file append-cstr
;

: build-output-file-names ( -- )
	build-base-file-name 
	build-assembly-file-name 
	build-object-file-name
	build-binary-file-name 
;

1 resq env-file
1 resq env-arg0
1 resq execve-file
1 resq execve-arg0
1 resq execve-arg1
1 resq execve-arg2
1 resq execve-arg3
1 resq execve-arg4

4 resq execve-argv \ TODO blocked by operation size issue

: execve-via-env ( -- noret )
	c" env" env-arg0 !
	c" /usr/bin/env" env-arg0 envp @ execve ;

\ TODO these are here to work around the operation size issue
: set-args ( arg1:rsi arg2:rax arg3:rcx -- ) execve-arg3 ! execve-arg2 ! execve-arg1 ! ;
: clear-args ( -- ) 0 0 0 set-args ;
: prep-execve ( file:rsi arg0:rax -- ) execve-arg0 ! execve-file ! clear-args ;

: generate-assembly ( -- ) 
	c" blue" blue-file @ prep-execve 
	fork dup 0 cmp ' execve-via-env xe
	waitpid 
;

: compile-assembly ( -- ) 
	c" nasm" assembly-file prep-execve
	c" -f" execve-arg1 !
	c" elf64" execve-arg2 !
	c" -o" execve-arg3 !
	object-file execve-arg4 !
	fork dup 0 cmp ' execve-via-env xe
	waitpid
;

\ TODO
: link-binary ( -- ) ;

\ TODO check wait-status after each call
: build ( -- noret ) 
	generate-assembly
	compile-assembly
	link-binary 
	bye 
;

: run ( -- noret ) s" need to run..." type newline bye ;

: cmd-table ( -- noret )
	decb( 0 0 0 98 117 105 108 100 ) ' build decq
	decb( 0 0 0 0 0 114 117 110 ) ' run decq
;

: cmd-key ( qword:rax len:rcx -- key:rax ) 8 sub neg 3 shl shl ;
: cstr>cmd-key ( cstr:rdx -- key:rax ) cstr>str swap @ swap cmd-key ;
: call-cmd ( cmd:rdi -- noret ) @ call ;

: call-cmd-with-key ( key:rax -- noret ) 2 ' cmd-table rot
: scan-cmd-table ( tries:ecx tbl:rdi key:rax -- noret ) 
	scasq ' call-cmd xe drop 8 add latest loop
	usage
;

: call-named-cmd ( name:rdx -- noret ) cstr>cmd-key call-cmd-with-key ;
: call-specified-cmd ( -- noret ) cmd-name @ call-named-cmd ;

: _start ( rsp -- noret ) 
	parse-args
	make-build-dirs 
	build-output-file-names
	call-specified-cmd
;
