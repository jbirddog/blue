; low ops used for testing and producing TAP output

EAX = 0x00
EDX = 0x02
ESI = 0x06
EDI = 0x07

RSI = ESI
RDI = EDI

SYS_OPEN = 0x02

BLK_CODE = 0x07
BLK_TEST_INPUT = 0x09
BLK_TEST_OUTPUT = 0x0A

opcode_tbl:
.offset = 0x80

opBI	op_ifnot, 1, 0	;	( t/f fa -- ? )	Call fa if t/f is false
	comp
	endcomp
	swap
	ifelse
	ret
end_op

opBI	op_chkargc, 1, 0	;	( -- )	Exit with error unless argc is 2
	argc
	litb	0x02
	eq
	comp
		litb	0x01
		exit
	endcomp
	litop	op_ifnot_code
	ret
end_op

opBI	op_cmovd, 1, 0	;	( d b -- )	Compile mov b, dword
	litb	0xB8
	or
	cb
	cd
	ret
end_op

opBI	op_cmovq, 1, 0	;	( q b -- )	Compile mov b, qword
	litb	0x48
	cb
	litb	0xB8
	or
	cb
	cq
	ret
end_op

opBI	op_cret, 1, 0	;	( -- )	Compile ret
	litb	0xC3
	cb
	ret
end_op

opBI	op_cstosd, 1, 0	;	( -- )	Compile stosd
	litb	0xAB
	cb
	ret
end_op

opBI	op_csys, 1, 0	;	( -- )	Compile syscall
	litw	0x050F
	cw
	ret
end_op

opBI	op_cxord, 1, 0	;	( b -- )	Compile xor b, b
	litb	0x31
	cb
	dup
	litb	0x03
	shl
	or
	litb	0xC0
	or
	cb
	ret
end_op

opBI	op_tfd, 1, 0	;	( -- d )	Push fd of test input file
	litd	0x00
	ret
end_op

opBI	op_oblk, 1, 0	;	( -- a )	Push addr of TAP output's start
	litb	BLK_TEST_OUTPUT
	blk
	ret
end_op

opBI	op_thr, 1, 0	;	( -- a )	Push addr of TAP output's here
	litq	0x00
	ret
end_op

opBI	op_setthr, 1, 0	;	( a -- )	Set addr of TAP output's here
	litb	op_thr_code
	setvarq
	ret
end_op

opBI	op_cdstarg, 1, 0	;	( -- )	Compile movabs rdi, _addr of argv[1]_
	argv
	litb	0x08
	add
	atq
	litb	RDI
	litop	op_cmovq_code
	ret
end_op

opBI	op_cflgsro, 1, 0	;	( -- )	Compile xor esi, esi (flags = READ_ONLY)
	litb	ESI
	litop	op_cxord_code
	ret
end_op

opBI	op_csopen, 1, 0	;	( -- )	Compile mov eax, 0x02 (sys_open); syscall
	litb	SYS_OPEN
	litb	EAX
	litop	op_cmovd_code
	litop	op_csys_code
	ret
end_op

opBI	op_cdsttfd, 1, 0	;	( -- )	Compile movabs rdi, _addr of tfd's litd_
	litb	op_tfd_code
	op
	litb	0x03
	add
	litb	RDI
	litop	op_cmovq_code
	ret
end_op

opBI	op_cfrmtfd, 1, 0	;	( -- )	Compile mov edi, _tfd_
	litop	op_tfd_code
	litb	EDI
	litop	op_cmovd_code
	ret
end_op

opBI	op_csrctib, 1, 0	;	( -- )	Compile mov rsi, _addr of _test input block_
	litb	BLK_TEST_INPUT
	blk
	litb	RSI
	litop	op_cmovq_code
	ret
end_op

opBI	op_cblklen, 1, 0	;	( -- )	Compile mov edx, 0x0400
	litw	0x400
	litb	EDX
	litop	op_cmovd_code
	ret
end_op

opBI	op_csread, 1, 0	;	( -- )	Compile xor eax, eax; syscall
	litb	EAX
	litop	op_cxord_code
	litop	op_csys_code
	ret
end_op

opBI	op_opentst, 1, 0	;	( -- )	Open argv[1] and set tfd
	here
	
	litop	op_cdstarg_code
	litop	op_cflgsro_code
	litop	op_csopen_code

	litop	op_cdsttfd_code
	litop	op_cstosd_code
	litop	op_cret_code

	mccall
	; TODO: check fd
	ret
end_op

opBI	op_readtst, 1, 0	;	( -- )	Read block from tfd into the test input block
	here

	litop	op_cfrmtfd_code
	litop	op_csrctib_code
	litop	op_cblklen_code
	litop	op_csread_code
	litop	op_cret_code

	mccall
	ret
end_op

opBI	op_runtst, 1, 0	;	( -- )	Run the test in the test input block
	litb	BLK_CODE
	blk
	litb	here.code
	setvarq

	litb	BLK_TEST_INPUT
	blk
	call
	ret
end_op

opBI	op_endl, 1, 0	;	( a -- )	End line of output and set TAP output's here
	litb	0x0A
	setincb
	litop	op_setthr_code
	ret
end_op

opBI	op_woka, 1, 0	;	( a -- )	Write ok line to addr
	litw	'ok'
	setincw
	litop	op_endl_code
	ret
end_op

opBI	op_wprep, 1, 0	;	( -- )	Preps the write system call
	; xor eax, eax
	; inc eax
	; mov edi, eax
	litw	0xC031
	cw
	litw	0xC0FF
	cw
	litw	0xC789
	cw
	ret
end_op

opBI	op_wlen, 1, 0	;	( -- )	Buffer length for the write system call
	; mov edx, _buffer len_
	litb	0xBA
	cb
	litop	op_thr_code
	litop	op_oblk_code
	sub
	cd
	ret
end_op

opBI	op_waddr, 1, 0	;	( -- )	Addr of the buffer for the write system call
	; movabs rsi, _addr of string_
	litw	0xBE48
	cw
	litop	op_oblk_code
	cq
	ret
end_op

;;;

opBI	op_test, 1, 0	;	( w -- )	Initialize a test suite
	litop	op_oblk_code
	litop	op_setthr_code
	ret
end_op

opBI	op_plan, 1, 0	;	( w -- )	Plan w tests where w is two ascii characters such as '03'
	litop	op_thr_code
	litw	'1.'
	setincw
	litb	'.'
	setincb
	swap
	setincw
	litop	op_endl_code
	ret
end_op

opBI	op_ok, 1, 0	;	( -- )	Write ok line to TAP output's here
	litop	op_thr_code
	litop	op_woka_code
	ret
end_op

opBI	op_notok, 1, 0	;	( -- )	Write not ok line to TAP output's here
	litop	op_thr_code
	litd	'not '
	setincd
	litop	op_woka_code
	ret
end_op

opBI	op_okif, 1, 0	;	( t/f -- )	Ok if top of stack is true
	comp
		litop	op_ok_code
	endcomp
	comp
		litop	op_notok_code
	endcomp
	ifelse
	ret
end_op

opBI	op_okeq, 1, 0	;	( a b -- )	Ok if a and b are eq
	eq
	litop	op_okif_code
	ret
end_op

opBI	op_okne, 1, 0	;	( a b -- )	Ok if a and b are not eq
	eq
	not
	litop	op_okif_code
	ret
end_op

opBI	op_ok0, 1, 0	;	( n -- )	Ok if top of stack is 0
	litb	0x00
	eq
	litop	op_okif_code
	ret
end_op

opBI	op_okn0, 1, 0	;	( n -- )	Ok if top of stack is not 0
	litb	0x00
	eq
	not
	litop	op_okif_code
	ret
end_op

opBI	op_done, 1, 0	;	( -- )	Writes TAP output to stdout and exits with depth as status
	here
	litop	op_wprep_code
	litop	op_wlen_code
	litop	op_waddr_code
	litop	op_csys_code
	litop	op_cret_code
	mccall
	depth
	exit
end_op
