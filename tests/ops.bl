
# stack depth is 0
depth litb 00 = assert

#
# t/f
#

true not false = assert
false not true = assert
true false = not assert

#
# test data stack ops
#

# stack depth is 1 after pushing a value
litb 10 depth litb 01 = assert

# stack depth is 0 after dropping the value
drop depth litb 00 = assert

# not
depth litb 02 = not assert

# swap
litb 02 litb 01 swap depth = assert drop

# -
litb 09 litb 07 - litb 02 = assert

# +
litb 07 litb 02 + litb 09 = assert

# dup
here dup = assert

# >r and r>
here >r r> here = assert

#
# test compiling bytecode
#

# when done compiling bytecode a ret is added and the address where the compile began is pushed
[ ] b@ litb ret = assert

# compile does not interpret non immediate opcodes
[ exit ] drop

# compile multi byte opcodes
[ litb FF ] drop

# compile writes expected byte
here litb 02 - b@ litb FF = assert

# compile writes the expected number of bytes (3 + 1 for ret)
[ here start - ] here swap - litb 04 = assert

#
# test calling compiled bytecode
#

litb 05 litb 02 [ - ] call

depth litb 01 = assert
litb 03 = assert

# test b!+
here

here litb 01 b!+

litb 01 - = assert

# test d!+
here

here litb 01 d!+

litb 04 - = assert

# test !+
here

here litb 01 !+

litb 08 - = assert

# test b,
here

litb C3 b,
here litb 01 - b@
litb C3 = assert

here litb 01 - = assert

# test d,
here

litb C3 d,
here litb 04 - b@
litb C3 = assert

here litb 04 - = assert

# test ,
here

litb C3 ,
here litb 08 - b@
litb C3 = assert

here litb 08 - = assert

#
# test calling compiled machine code
#

# call address that immediately returns
here litb C3 b, mccall

# push two numbers, compile and call machine code that calls the + opcode
litb 03 litb 05

here

# xor eax, eax
# mov al, _+ opcode_
litb 31 b, litb C0 b,
litb B0 b, litb + b,

# movabs rdi, _addr of opcode call_
litb 48 b, litb BF b,
start litb 40 - @ ,

# call rdi
litb FF b, litb D7 b,

# ret
litb C3 b,

mccall

litb 08 = assert

#
# control flow
#

start start = [ litb 01 ] if
start dup litb 0A + = not [ litb 03 ] if

+ litb 04 = not [ litb FF exit ] if

#
# fin
#

# set code buffer back to start
start here! start here = assert

# exit cleanly if stack is prestine
depth exit
