
#
# test initial vm state
#

# stack depth is 0
depth litb 00 = assert

# code buffer here is same as its start
start here = assert

#
# test data stack ops
#

# stack depth is 1 after pushing a value
litb 10 depth litb 01 = assert

# stack depth is 0 after dropping the value
drop depth litb 00 = assert

# not
depth litb 02 = not assert

# swap
litb 02 litb 01 swap depth = assert drop

# -
litb 09 litb 07 - litb 02 = assert

# +
litb 07 litb 02 + litb 09 = assert

# dup
here dup = assert

#
# test opcode handlers
#

# set opcode handler to compile, back to interpret
[ ]

# compile does not interpret non immediate opcodes
[ exit ]

# check code buffer here is one byte from the start
here start - litb 01 = assert

# compile multi byte opcodes
[ litb FF ]

# check code buffer here is three bytes from the start
here start - litb 03 = assert

# compile writes expected byte
here litb 01 - b@ litb FF = assert

#
# test calling compiled bytecode
#

here [ here start - ret ] execute

depth litb 01 = assert
litb 07 = assert

# test b!+
here

here 01 b!+

litb 01 - = assert

# test d!+
here

here 01 d!+

litb 04 - = assert

# test !+
here

here 01 !+

litb 08 - = assert

# test b,
here

litb C3 b,
here litb 01 - b@
litb C3 = assert

here litb 01 - = assert

# test d,
here

litb C3 d,
here litb 04 - b@
litb C3 = assert

here litb 04 - = assert

# test ,
here

litb C3 ,
here litb 08 - b@
litb C3 = assert

here litb 08 - = assert

#
# test calling compiled machine code
#

# call address that immediately returns
here litb C3 b, call

# push two numbers, compile and call machine code that calls the + opcode
litb 03 litb 05

here

# xor eax, eax
# mov al, _+ opcode_
litb 31 b, litb C0 b,
litb B0 b, litb + b,

# movabs rdi, _addr of opcode call_
litb 48 b, litb BF b,
start litb 40 - @ ,

# call rdi
litb FF b, litb D7 b,

# ret
litb C3 b,

call

litb 08 = assert

#
# fin
#

# set code buffer back to start
start here! start here = assert

# exit cleanly if stack is prestine
depth exit
