
#
# test initial vm state
#

# stack depth is 0
depth litb 00 = assert

# code buffer here is same as its start
start here = assert

#
# test data stack ops
#

# stack depth is 1 after pushing a value
litb 10 depth litb 01 = assert

# stack depth is 0 after dropping the value
drop depth litb 00 = assert

# not
depth litb 02 = not assert

# swap
litb 02 litb 01 swap depth = assert drop

# -
litb 09 litb 07 - litb 02 = assert

# +
litb 07 litb 02 + litb 09 = assert

#
# test opcode handlers
#

# set opcode handler to compile, back to interpret
] [

# compile does not interpret non immediate opcodes
] halt [

# check code buffer here is one byte from the start
here start - litb 01 = assert

# compile multi byte opcodes
] litb FF [

# check code buffer here is three bytes from the start
here start - litb 03 = assert

# compile writes expected byte
here litb 01 - b@ litb FF = assert

#
# test calling compiled bytecode
#

here ] here start - ret [ execute

depth litb 01 = assert
litb 07 = assert

# test writing byte to the code buffer
here

litb C3 b,
here litb 01 - b@
litb C3 = assert

here litb 01 - = assert

#
# test calling compiled machine code
#

here litb C3 b, call

#
# fin
#

# check stack is prestine and halt
depth litb 00 = assert
halt

# this shouldn't run
litb FF depth assert = 
