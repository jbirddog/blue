# BlueVM

Minimalistic 64 bit Forth-like virtual machine for hackers. The BlueVM aims to:

1. Have a simplistic and hackable codebase
1. Support execution of any previously compiled bytecode
1. Provide a minimal set of opcodes that can be extended by the host
1. Serve as the basis for minimalistic handcrafted applications
1. Allow the host full control

## Memory Layout

The BlueVM requires a single allocation with the following layout in rwx memory:

1. Input Buffer (1024 bytes)
1. Data Stack (1024 bytes)
1. Opcode Map (2048 bytes)
   1. BlueVM Opcode Map (1024 bytes)
   1. Extended Opcode Map (1024 bytes)
1. Code Buffer (4096 bytes)
   1. BlueVM Data (128 bytes)
   1. Space for Host (3968 bytes)

## Boot

When the BlueVM starts it will perform the allocation mentioned above and set the following 8 byte values in the
BlueVM Data portion of the beginning of the code buffer:

1. BlueVM state
1. Location of the input buffer
1. Location of the input buffer's here
1. Input buffer length
1. Location of the data stack
1. Location of the data stack's here
1. Data stack length
1. Location of the opcode map
1. Location of the code buffer
1. Location of the code buffer's here
1. Code buffer length

BlueVM will then read 1024 bytes from stdin into the input buffer and begin interpreting the bytecode. The contents
of this initial 1024 bytes serve as the bootstrap for the host.

## Execution

BlueVM follows a simple byte oriented execution strategy. Using the values from the BlueVM data portion of the code
buffer it:

1. Checks if a byte is available in the input buffer
   1. If not exit
   1. If so read a byte and increment the input buffer's here by one byte
1. Locate the opcode entry in the opcode map
   1. If it is 0 exit with bad opcode
1. Check the BlueVM state to see if the mode is set to compile or interpret
   1. If interpret jump to the op's code (TODO: elaborate - native vs bytecode ops)
   1. If compile copy the number of bytes specified in the opcode header to the code buffer, advancing here
