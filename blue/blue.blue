global _start

: syscall ( num:eax -- result:eax ) syscall ;
: exit ( status:rdi -- noret ) 60 syscall ;

\ : syscall3 ( arg2:rsi arg3:edx arg1:edi num:eax -- result:eax ) syscall ;

\ : write ( buf:rsi len:edx fd:edi -- result:eax ) 1 syscall3 ;

\ TODO this is an example of hacky stack handling due to lodsb/loopne
: find0 ( start:rsi max:rcx -- end:rsi ) lodsb 0 cmp latest loopne ; 

: range-len ( start:rdi end:rsi -- len:rsi ) swap sub dec ;
: cstr-range ( start:rdi -- begin:rdi end:rsi ) dup -1 find0 ;
: strlen ( str:rsi -- len:rsi ) cstr-range range-len ;

\ TODO lea
: next-arg ( argv:rsp -- arg:rsi ) 8 add [] 
: deref ( rsi -- rsi ) ; \ TODO ideally shouldn't need this

\ need to next-arg dup len writeln
: _start ( rsp -- noret ) next-arg strlen exit ;

\ argc [rsp] -> rcx for looping over argv
\ argv lea rsi, [rsp+8], lodsq loop will load each string ptr into rax
\ scan rax til 0 to find length
\ print with length
\ print new line
