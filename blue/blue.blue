global _start

: syscall ( num:eax -- result:eax ) syscall ;

60 const exit

: exit ( status:edi -- noret ) exit syscall ;
: exit.ok ( -- noret ) 0 exit ;
: exit.syserr ( err:eax -- noret ) neg exit ;

: unwrap ( result:eax -- value:eax ) dup 0 cmp ' exit.syserr xl ;
: ordie ( result -- ) unwrap drop ;

: syscall ( arg2:esi arg3:edx arg1:edi num:eax -- result:eax ) syscall ;

1 const stdout
1 const write

: write ( buf len -- ) stdout write syscall ordie ;

: lf ( -- ) 10 decb 
: newline ( -- ) ' lf 1 write ;

: writeln ( buf len -- ) write newline ; 

: find0 ( start:rsi -- end:rsi ) lodsb 0 cmp latest xne ; 
: cstrlen ( str:rdi -- len:rsi ) dup find0 swap sub dec ;
: cstr>str ( cstr:rdx -- str:rsi len:rdx ) dup cstrlen xchg ;

\ TODO lea
: next-arg ( argv:rbp -- arg:rdx ) 8 add [] 
: _ ( rdx -- rdx ) ; \ TODO ideally shouldn't need

1 resq argc
1 resq argv

: argc! ( rsp -- ) argc ! ;
: argv! ( rbp -- ) 8 add argv ! ;

\ need to next-arg dup len writeln
: _start ( rsp -- noret ) next-arg cstr>str writeln exit.ok ;
