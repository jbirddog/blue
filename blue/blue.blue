global _start

: syscall ( num:eax -- result:eax ) syscall ;

: exit ( status:edi -- noret ) 60 syscall ;
: exit.ok ( -- noret ) 0 exit ;
: exit.syserr ( err:eax -- noret ) neg exit ;

: unwrap ( result:eax -- value:eax ) dup 0 cmp ' exit.syserr xl ;

: syscall3 ( arg2:esi arg3:edx arg1:edi num:eax -- result:eax ) syscall ;

1 const stdout

: write ( buf len -- result ) stdout 1 syscall3 ;
: write! ( buf len -- wrote ) write unwrap ;

1 const lf.len

: lf ( -- ) 10 decb 
: lf ( -- wrote ) ' lf lf.len write! ;

: writeln! ( buf len -- x x ) write lf ; 

\ TODO this is an example of invalid stack handling due to lodsb/loopne
: find0 ( start:rsi max:rcx -- end:rsi ) lodsb 0 cmp latest loopne ; 

: range-len ( start:rdi end:rsi -- len:rsi ) swap sub dec ;
: cstr-range ( start:rdi -- begin:rdi end:rsi ) dup -1 find0 ;
: strlen ( str:rsi -- len:rsi ) cstr-range range-len ;

\ TODO lea
: next-arg ( argv:rbp -- arg:rdx ) 8 add [] 
: _ ( rdx -- rdx ) ; \ TODO ideally shouldn't need

1 resq argc
1 resq argv

: argc! ( rsp -- ) argc ! ;
: argv! ( rbp -- ) 8 add argv ! ;

\ need to next-arg dup len writeln
: _start ( rsp -- noret ) next-arg dup strlen xchg writeln! exit.ok ;

